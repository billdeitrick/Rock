<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <NotificationBox v-if="!isValidAttendanceOccurrence" :alertType="AlertType.Warning">
        Unable to schedule this occurrence.
    </NotificationBox>

    <div v-else class="location">
        <div class="d-flex">
            <span class="d-block text-sm">
                {{ title }}
            </span>
        </div>

        <NotificationBox v-if="updateResourceWarningMessage" :alertType="AlertType.Warning">
            {{ updateResourceWarningMessage }}
        </NotificationBox>

        <NotificationBox v-if="getResourcesWarningMessage" :alertType="AlertType.Warning">
            {{ getResourcesWarningMessage }}
        </NotificationBox>

        <ul v-else class="list-group list-group-sched">

            <ScheduledResource v-for="resource in resources" :key="resource.AttendanceId"
                               :resource="resource"
                               v-model:updateResourceWarningMessage="updateResourceWarningMessage"
                               @resourceUpdated="onResourceUpdated"></ScheduledResource>

            <li class="list-group-item d-flex align-items-center">
                <ProgressBar :progress="scheduleProgress"></ProgressBar>
                <RockButton type="button"
                            class="circle-plus"
                            :disabled="isLoadingResources"
                            @click="onSelectIndividualsClick">
                    <i class="fa fa-plus"></i>
                </RockButton>
            </li>
        </ul>

        <SelectIndividuals v-model:isVisible="isSelectingIndividuals"
                           :occurrence="occurrence"></SelectIndividuals>

    </div>
</template>

<script setup lang="ts">
    import { computed, PropType, ref } from "vue";
    import ProgressBar from "./progressBar.partial.obs";
    import ScheduledResource from "./scheduledResource.partial.obs";
    import SelectIndividuals from "./selectIndividuals.partial.obs";
    import { IScheduleProgress, ISchedulerResourceAttend } from "./types.partial";
    import NotificationBox from "@Obsidian/Controls/notificationBox.obs";
    import RockButton from "@Obsidian/Controls/rockButton";
    import { AlertType } from "@Obsidian/Enums/Controls/alertType";
    import { ScheduledAttendanceItemStatus, ScheduledAttendanceItemStatusDescription } from "@Obsidian/Enums/Event/scheduledAttendanceItemStatus";
    import { useHttp } from "@Obsidian/Utility/http";
    import { GroupSchedulerOccurrenceBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduler/groupSchedulerOccurrenceBag";

    const props = defineProps({
        occurrence: {
            type: Object as PropType<GroupSchedulerOccurrenceBag>,
            required: true
        }
    });

    const http = useHttp();

    // #region Values

    const isSelectingIndividuals = ref(false);
    const isLoadingResources = ref(true);
    const getResourcesWarningMessage = ref("");
    const updateResourceWarningMessage = ref("");

    const resources = ref<ISchedulerResourceAttend[]>([]);

    // #endregion

    // #region Computed Values

    const title = computed((): string => {
        return props.occurrence?.locationName || "Location";
    });

    const attendanceOccurrenceId = computed((): number => {
        return props.occurrence?.attendanceOccurrenceId ?? 0;
    });

    const isValidAttendanceOccurrence = computed((): boolean => {
        return attendanceOccurrenceId.value > 0;
    });

    const confirmedCount = computed((): number => {
        var confirmed = ScheduledAttendanceItemStatusDescription[ScheduledAttendanceItemStatus.Confirmed].toLowerCase();
        return resources.value
            .filter((r: ISchedulerResourceAttend) => r.ConfirmationStatus === confirmed)
            .length;
    });

    const pendingCount = computed((): number => {
        var pending = ScheduledAttendanceItemStatusDescription[ScheduledAttendanceItemStatus.Pending].toLowerCase();
        return resources.value
            .filter((r: ISchedulerResourceAttend) => r.ConfirmationStatus === pending)
            .length;
    });

    const scheduleProgress = computed((): IScheduleProgress => {
        let minimumCapacity: number | null | undefined;
        let desiredCapacity: number | null | undefined;
        let maximumCapacity: number | null | undefined;

        if (props.occurrence) {
            minimumCapacity = props.occurrence.minimumCapacity;
            desiredCapacity = props.occurrence.desiredCapacity;
            maximumCapacity = props.occurrence.maximumCapacity;
        }

        const progress = {
            minimumCapacity,
            desiredCapacity,
            maximumCapacity,
            confirmedCount: confirmedCount.value,
            pendingCount: pendingCount.value
        };

        return progress;
    });

    // #endregion

    // #region Functions

    async function getCurrentResources(): Promise<void> {
        isLoadingResources.value = true;
        getResourcesWarningMessage.value = "";
        updateResourceWarningMessage.value = "";

        const result = await http.get<ISchedulerResourceAttend[]>(`/api/Attendances/GetAttendingSchedulerResources?attendanceOccurrenceId=${attendanceOccurrenceId.value}`);
        isLoadingResources.value = false;

        if (!result.isSuccess) {
            getResourcesWarningMessage.value = result.errorMessage ?? "Unknown error when trying to get current resources.";
            return;
        }

        resources.value = result.data ?? [];
    }

    // #endregion

    // #region Event Handlers

    /**
     * Handles the `resourceUpdated` event of the scheduled resource component.
     */
    function onResourceUpdated(): void {
        getCurrentResources();
    }

    /**
     * Handles the click event of the select individuals button.
     */
    function onSelectIndividualsClick(): void {
        isSelectingIndividuals.value = true;
    }

    // #endregion

    getCurrentResources();
</script>
