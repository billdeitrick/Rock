<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div :class="`progress text-${state} m-0 flex-fill`" role="progressbar" aria-label="Group Scheduler Progress">
        <div :class="`progress-bar bg-${state}`" :style="`width:${confirmedPercentage}%`"></div>
        <div :class="`progress-bar bg-${state} o-50`" :style="`width:${pendingPercentage}%`"></div>

        <div v-if="showMinimumThreshold"
             ref="minimumThreshold"
             class="indicator"
             :style="`left:${minimumPercentage}%;`"
             data-toggle="tooltip"
             :title="`Minimum: ${minimumCapacity}`"></div>

        <div v-if="showDesiredThreshold"
             ref="desiredThreshold"
             class="indicator"
             :style="`left:${desiredPercentage}%;`"
             data-toggle="tooltip"
             :title="`Desired: ${desiredCapacity}`"></div>

        <div v-if="showMaximumThreshold"
             ref="maximumThreshold"
             class="indicator"
             :style="`left:${maximumPercentage}%;`"
             data-toggle="tooltip"
             :title="`Max: ${maximumCapacity}`"></div>
    </div>
</template>

<script setup lang="ts">
    import { computed, nextTick, onMounted, PropType, ref, watch } from "vue";
    import { IScheduleProgress, ProgressState } from "./types.partial";
    import { tooltip } from "@Obsidian/Utility/tooltip";

    const props = defineProps({
        progress: {
            type: Object as PropType<IScheduleProgress>,
            required: true
        }
    });

    // #region Values

    const minimumThresholdElement = ref<HTMLElement | null>(null);
    const desiredThresholdElement = ref<HTMLElement | null>(null);
    const maximumThresholdElement = ref<HTMLElement | null>(null);

    // #endregion

    // #region Computed Values

    const minimumCapacity = computed((): number => {
        return props.progress?.minimumCapacity ?? 0;
    });

    const minimumPercentage = computed((): number => {
        return getPercentageOfWhole(minimumCapacity.value);
    });

    const showMinimumThreshold = computed((): boolean => {
        return minimumPercentage.value > 0 && minimumPercentage.value < 100;
    });

    const desiredCapacity = computed((): number => {
        return props.progress?.desiredCapacity ?? 0;
    });

    const desiredPercentage = computed((): number => {
        return getPercentageOfWhole(desiredCapacity.value);
    });

    const showDesiredThreshold = computed((): boolean => {
        return desiredPercentage.value > 0 && desiredPercentage.value < 100;
    });

    const maximumCapacity = computed((): number => {
        return props.progress?.maximumCapacity ?? 0;
    });

    const maximumPercentage = computed((): number => {
        return getPercentageOfWhole(maximumCapacity.value);
    });

    const showMaximumThreshold = computed((): boolean => {
        return maximumPercentage.value > 0
            && maximumPercentage.value < 100
            && totalCount.value > maximumCapacity.value;
    });

    const confirmedCount = computed((): number => {
        return props.progress?.confirmedCount ?? 0;
    });

    const confirmedPercentage = computed((): number => {
        return getPercentageOfWhole(confirmedCount.value, false);
    });

    const pendingCount = computed((): number => {
        return props.progress?.pendingCount ?? 0;
    });

    const pendingPercentage = computed((): number => {
        const pendingCountForPercentage = pendingCount.value + confirmedCount.value;
        return getPercentageOfWhole(pendingCountForPercentage, false);
    });

    const totalCount = computed((): number => {
        return confirmedCount.value + pendingCount.value;
    });

    const state = computed((): string => {
        const min = minimumCapacity.value;
        const desired = desiredCapacity.value;
        const max = maximumCapacity.value;
        const filled = totalCount.value;

        let progressState = ProgressState.danger;
        if (filled > 0) {
            progressState = ProgressState.success;
            if (max > 0 && filled > max) {
                progressState = ProgressState.critical;
            }
            else if (filled < min) {
                progressState = ProgressState.danger;
            }
            else if (filled < desired) {
                progressState = ProgressState.warning;
            }
        }

        return progressState;
    });

    const whole = computed((): number => {
        const min = minimumCapacity.value;
        const desired = desiredCapacity.value;
        const max = maximumCapacity.value;
        const filled = totalCount.value;

        let whole = 0;
        if (max > 0) {
            whole = max;
        }
        else if (desired > 0) {
            whole = desired;
        }
        else if (min > 0) {
            whole = min;
        }

        if (filled > whole) {
            whole = filled;
        }

        return whole;
    });

    // #endregion

    // #region Functions

    /**
     * Gets the part's percentage of the whole.
     *
     * @param part The part whose percentage should be calculated.
     * @param isThreshold Whether this percentage represents a threshold (true) or resource count (false);
     */
    function getPercentageOfWhole(part: number, isThreshold = true): number {
        if (whole.value > 0) {
            if (isThreshold) {
                // Show threshold "ticks" to the left of the spot that will satisfy a given value.
                part = part > 0 ? part - 1 : part;
            }

            var percentage = Math.floor(part / whole.value * 100);
            return percentage > 100 ? 100 : percentage;
        }

        return 0;
    }

    function configureTooltips(): void {
        if (minimumThresholdElement.value) {
            tooltip(minimumThresholdElement.value);
        }

        if (desiredThresholdElement.value) {
            tooltip(desiredThresholdElement.value);
        }

        if (maximumThresholdElement.value) {
            tooltip(maximumThresholdElement.value);
        }
    }

    // #endregion

    watch([
        minimumThresholdElement,
        desiredThresholdElement,
        maximumThresholdElement
    ], () => {
        configureTooltips();
    });

    watch([
        minimumCapacity,
        desiredCapacity,
        maximumCapacity
    ], () => {
        nextTick(() => {
            configureTooltips();
        });
    });

    onMounted(() => {
        configureTooltips();
    });
</script>
