<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Modal v-model="isVisible" title="Filters" saveText="Apply" @save="onSave" :disabled="isApplyingFilters">

        <Alert :alertType="AlertType.Info">
            Select the filter options below to limit what is shown on the group scheduler.
        </Alert>

        <Alert v-if="warningMessage" :alertType="AlertType.Warning">
            {{ warningMessage }}
        </Alert>

        <GroupPicker v-model="selectedGroups"
                     label="Groups"
                     :multiple="true"
                     :limitToSchedulingEnabled="true"
                     :autoExpand="true"
                     :disabled="isApplyingFilters"
                     rules="required"
                     @update:modelValue="onFiltersChanged('GroupPicker', $event)" />

        <SlidingDateRangePicker v-model="selectedDateRange"
                                label="Dates"
                                previewLocation="Top"
                                :enabledSlidingDateRangeUnits="enabledDateRangeTypes"
                                :disallowPastDateSelection="true"
                                :disabled="isApplyingFilters"
                                @update:modelValue="onFiltersChanged('SlidingDateRangePicker', $event)" />

        <DropDownList v-model="selectedLocationIds"
                      label="Locations"
                      :items="availableLocations"
                      :multiple="true"
                      :loading="isApplyingFilters"
                      @blur="onFiltersChanged('LocationsPicker', $event)" />

        <DropDownList v-model="selectedScheduleIds"
                      label="Schedules"
                      :items="availableSchedules"
                      :multiple="true"
                      :loading="isApplyingFilters"
                      @blur="onFiltersChanged('SchedulesPicker', $event)" />

    </Modal>
</template>

<script setup lang="ts">
    import { computed, nextTick, PropType, ref, watch } from "vue";
    import Alert from "@Obsidian/Controls/alert.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList";
    import GroupPicker from "@Obsidian/Controls/groupPicker";
    import Modal from "@Obsidian/Controls/modal";
    import SlidingDateRangePicker from "@Obsidian/Controls/slidingDateRangePicker.obs";
    import { AlertType } from "@Obsidian/Enums/Controls/alertType";
    import { SlidingDateRangeType } from "@Obsidian/Enums/Controls/slidingDateRangeType";
    import { useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { SlidingDateRange } from "@Obsidian/Utility/slidingDateRange";
    import { GroupSchedulerAppliedFiltersBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduler/groupSchedulerAppliedFiltersBag";
    import { GroupSchedulerOccurrenceBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduler/groupSchedulerOccurrenceBag";
    import { SlidingDateRangeBag } from "@Obsidian/ViewModels/Controls/slidingDateRangeBag";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    const invokeBlockAction = useInvokeBlockAction();

    const props = defineProps({
        isVisible: {
            type: Boolean as PropType<boolean>,
            required: true
        },

        appliedFilters: {
            type: Object as PropType<GroupSchedulerAppliedFiltersBag>,
            required: true
        }
    });

    const emit = defineEmits<{
        (e: "update:isVisible"): void,
        (e: "applyFilters", value: GroupSchedulerAppliedFiltersBag): void
    }>();

    // #region Values

    const isVisible = useVModelPassthrough(props, "isVisible", emit);

    const isApplyingFilters = ref(false);
    const warningMessage = ref("");
    const isCanceled = ref(true);

    const originalValue = ref(props.appliedFilters);

    const selectedGroups = ref<ListItemBag[]>(props.appliedFilters?.filters?.groups ?? []);
    const selectedDateRange = ref<SlidingDateRange | null>(getSlidingDateRange(props.appliedFilters?.filters?.dateRange));
    const availableLocations = ref<ListItemBag[]>(props.appliedFilters?.filters?.locations?.availableLocations ?? []);
    const selectedLocations = ref<ListItemBag[]>(props.appliedFilters?.filters?.locations?.selectedLocations ?? []);
    const availableSchedules = ref<ListItemBag[]>(props.appliedFilters?.filters?.schedules?.availableSchedules ?? []);
    const selectedSchedules = ref<ListItemBag[]>(props.appliedFilters?.filters?.schedules?.selectedSchedules ?? []);
    const scheduleOccurrences = ref<GroupSchedulerOccurrenceBag[] | null | undefined>(props.appliedFilters?.scheduleOccurrences);

    // #endregion

    // #region Computed Values

    const enabledDateRangeTypes = computed((): SlidingDateRangeType[] => {
        return [
            SlidingDateRangeType.Current,
            SlidingDateRangeType.DateRange,
            SlidingDateRangeType.Next,
            SlidingDateRangeType.Upcoming
        ];
    });

    const selectedLocationIds = computed<string[]>({
        get() {
            return selectedLocations.value
                ?.filter((item: ListItemBag) => item?.value)
                ?.map((item: ListItemBag) => item.value ?? "") ?? [];
        },
        set(newValue: string[]) {
            selectedLocations.value = newValue.map((value: string) => ({
                value
            }));
        }
    });

    const selectedScheduleIds = computed<string[]>({
        get() {
            return selectedSchedules.value
                ?.filter((item: ListItemBag) => item?.value)
                ?.map((item: ListItemBag) => item.value ?? "") ?? [];
        },
        set(newValue: string[]) {
            selectedSchedules.value = newValue.map((value: string) => ({
                value
            }));
        }
    });

    // #endregion

    // #region Functions

    /**
     * Gets the sliding date range from the provided sliding date range bag.
     *
     * @param bag The date range bag from which to create a sliding date range.
     */
    function getSlidingDateRange(bag: SlidingDateRangeBag | null | undefined): SlidingDateRange | null {
        return bag
            ? bag as SlidingDateRange
            : null;
    }

    /**
     * Gets the current filters according the the controls' selected values.
     */
    function getCurrentFilters(): GroupSchedulerAppliedFiltersBag {
        var dateRange: SlidingDateRangeBag | null = selectedDateRange.value
            ? selectedDateRange.value as SlidingDateRangeBag
            : null;

        return {
            filters: {
                groups: selectedGroups.value,
                locations: {
                    availableLocations: availableLocations.value,
                    selectedLocations: selectedLocations.value
                },
                schedules: {
                    availableSchedules: availableSchedules.value,
                    selectedSchedules: selectedSchedules.value
                },
                dateRange
            },
            scheduleOccurrences: scheduleOccurrences.value
        };
    }

    /**
     * Sets the internal values using the provided filters.
     *
     * @param appliedFilters The filters value from which to set the internal values.
     */
    function setCurrentFilters(appliedFilters: GroupSchedulerAppliedFiltersBag | null): void {
        selectedGroups.value = appliedFilters?.filters?.groups ?? [];
        selectedDateRange.value = getSlidingDateRange(appliedFilters?.filters?.dateRange);
        availableLocations.value = appliedFilters?.filters?.locations?.availableLocations ?? [];
        selectedLocations.value = appliedFilters?.filters?.locations?.selectedLocations ?? [];
        availableSchedules.value = appliedFilters?.filters?.schedules?.availableSchedules ?? [];
        selectedSchedules.value = appliedFilters?.filters?.schedules?.selectedSchedules ?? [];
        scheduleOccurrences.value = appliedFilters?.scheduleOccurrences;
    }

    // #endregion

    // #region Event Handlers

    /**
     * Handles the `save` event of the select filters modal.
     */
    function onSave(): void {
        emit("applyFilters", getCurrentFilters());
        isCanceled.value = false;
        isVisible.value = false;
    }

    /**
     * Handles the updating of filter values within this component, based on the current combined values of all filter controls.
     */
    async function onFiltersChanged(target: string, event: any): Promise<void> {
        /*
         * When one of the filter controls triggers this event handler, we could find ourselves in an infinite loop without
         * this initial `isUpdatingFilters.value` check (because all such controls will be updated with the server's response
         * to the initial change event, thereby repeatedly triggering this event handler over and over). Note the `nextTick`
         * usage below, which will set `isUpdatingFilters.value` back to false once the controls have all had a chance to
         * update their values accordingly.
         */
        if (isApplyingFilters.value) {
            console.log(`${target}: Ignoring follow-up event.`);
            return;
        }

        isApplyingFilters.value = true;
        warningMessage.value = "";

        const result = await invokeBlockAction<GroupSchedulerAppliedFiltersBag>("ApplyFilters", { bag: getCurrentFilters().filters });
        if (!result.isSuccess) {
            isApplyingFilters.value = false;
            warningMessage.value = result.errorMessage || "Unknown error while trying to update available filters.";
            return;
        }

        setCurrentFilters(result.data);

        nextTick(() => {
            isApplyingFilters.value = false;
        });
    }

    // #endregion

    // Watch for applied filters props changes and update our original and internal values.
    watch(() => props.appliedFilters, () => {
        originalValue.value = props.appliedFilters;
        setCurrentFilters(props.appliedFilters);
    });

    // Watch for the modal closing without the save button being clicked and revert any changes to internal values.
    watch(isVisible, () => {
        if (isVisible.value) {
            isCanceled.value = true;
        }
        else {
            if (isCanceled.value) {
                setCurrentFilters(originalValue.value);
            }
        }
    });
</script>
