<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Alert v-if="blockErrorMessage" :alertType="AlertType.Warning">
        {{ blockErrorMessage }}
    </Alert>

    <div v-if="!blockErrorMessage" class="new-group-scheduler">
        <div class="panel panel-block styled-scroll">
            <div class="panel-heading">
                <h3 class="panel-title">Group Scheduler</h3>
            </div>

            <!-- Toolbar -->
            <div class="panel-collapsable">
                <!-- Desktop -->
                <div class="panel-toolbar d-none d-md-flex flex-wrap flex-sm-nowrap justify-content-between">
                    <div class="d-block text-muted clickable" @click="onSelectFiltersClick"><i class="fa fa-sliders-h"></i> {{ filtersText }}</div>

                    <div class="d-block">
                        <RockButton :btnSize="BtnSize.ExtraSmall"><i class="fa fa-clone"></i> Clone Schedules</RockButton>
                        <RockButton :btnSize="BtnSize.ExtraSmall"><i class="fa fa-calendar-check"></i> Rosters</RockButton>
                        <RockButton :btnSize="BtnSize.ExtraSmall"><i class="fa fa-magic"></i> Auto Schedule</RockButton>
                        <RockButton :btnSize="BtnSize.ExtraSmall"><i class="fa fa-envelope-o"></i> Send Now</RockButton>
                    </div>
                </div>

                <!-- Mobile -->
                <div class="panel-toolbar panel-toolbar-mobile d-flex d-md-none justify-content-between">
                    <RockButton :btnSize="BtnSize.Small" @click="onSelectFiltersClick"><i class="fa fa-sliders-h"></i> Filters</RockButton>

                    <div class="d-flex">
                        <div class="dropdown">
                            <button type="button"
                                    class="btn btn-default btn-square btn-sm"
                                    data-toggle="dropdown"
                                    aria-haspopup="true"
                                    aria-expanded="false">
                                <i class="fa fa-ellipsis-v"></i>
                            </button>
                            <ul class="dropdown-menu dropdown-menu-right">
                                <li>
                                    <button type="button"
                                            class="dropdown-item btn-link text-nowrap">
                                        <i class="fa fa-envelope-o"></i> Send Now
                                    </button>
                                </li>
                                <li>
                                    <button type="button"
                                            class="dropdown-item btn-link text-nowrap">
                                        <i class="fa fa-clone"></i> Clone Schedules
                                    </button>
                                </li>
                                <li>
                                    <button type="button"
                                            class="dropdown-item btn-link text-nowrap">
                                        <i class="fa fa-calendar-check"></i> Rosters
                                    </button>
                                </li>
                                <li>
                                    <button type="button"
                                            class="dropdown-item btn-link text-nowrap">
                                        <i class="fa fa-magic"></i> Auto Schedule
                                    </button>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Body -->
            <div class="panel-body p-0">

                <Alert v-if="!anyGroupsSelected" :alertType="AlertType.Info">
                    Please select at least one group.
                </Alert>

                <div v-else ref="snapContainer" class="snap-container">

                    <OccurrenceDate v-for="(occurrences, key, index) in occurrencesByDate" :key="key"
                                    :occurrences="occurrences"
                                    :showPrevNextButtons="showPrevNextButtons"
                                    @scheduleElementsCreated="onScheduleElementsCreated(index, $event)"
                                    @goPrevious="onGoPrevious(index, $event)"
                                    @goNext="onGoNext(index, $event)"></OccurrenceDate>

                </div>

            </div>
        </div>

        <SelectFilters v-model:isVisible="isSelectingFilters"
                       :appliedFilters="appliedFilters"
                       @filtersApplied="onFiltersApplied" />
    </div>
</template>

<script setup lang="ts">
    import { computed, nextTick, ref } from "vue";
    import OccurrenceDate from "./GroupScheduler/occurrenceDate.partial.obs";
    import SelectFilters from "./GroupScheduler/selectFilters.partial.obs";
    import Alert from "@Obsidian/Controls/alert.obs";
    import RockButton from "@Obsidian/Controls/rockButton";
    import { AlertType } from "@Obsidian/Enums/Controls/alertType";
    import { BtnSize } from "@Obsidian/Enums/Controls/btnSize";
    import { getSecurityGrant, onConfigurationValuesChanged, provideSecurityGrant, useConfigurationValues, useReloadBlock } from "@Obsidian/Utility/block";
    import { GroupSchedulerAppliedFiltersBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduler/groupSchedulerAppliedFiltersBag";
    import { GroupSchedulerFiltersBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduler/groupSchedulerFiltersBag";
    import { GroupSchedulerInitializationBox } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduler/GroupSchedulerInitializationBox";
    import { GroupSchedulerOccurrenceBag } from "@Obsidian/ViewModels/Blocks/Group/Scheduling/GroupScheduler/groupSchedulerOccurrenceBag";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    const config = useConfigurationValues<GroupSchedulerInitializationBox>();

    const securityGrant = getSecurityGrant(config.securityGrantToken);
    const reloadBlock = useReloadBlock();

    enum ScrollDirection {
        Previous,
        Next
    }

    // #region Values

    const snapContainer = ref<HTMLElement | null>(null);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const scheduleElementsByOccurrenceDate = ref<Record<number, any[]>>({});

    const filters = ref<GroupSchedulerFiltersBag | null | undefined>(config.filters);
    const scheduleOccurrences = ref<GroupSchedulerOccurrenceBag[] | null | undefined>(config.scheduleOccurrences);

    const isSelectingFilters = ref(false);

    // #endregion

    // #region Computed Values

    const blockErrorMessage = computed((): string | undefined | null => {
        return config.errorMessage;
    });

    const anyGroupsSelected = computed((): boolean => {
        return !!filters.value?.groups?.length;
    });

    const filtersText = computed((): string => {
        const currentFilters = filters.value;

        function getSingleItemOrCount(items: ListItemBag[] | null | undefined, label: string): string {
            if (items?.length) {
                if (items.length === 1 && items[0]) {
                    return items[0].text || "";
                }

                label = items.length === 1 ? label : `${label}s`;
                return `${items.length} ${label}`;
            }

            return `All ${label}s`;
        }

        const filtersTextSegements: string[] = [
            currentFilters?.groups?.length ? currentFilters.groups.map(g => g.text).join(", ") : "",
            currentFilters?.friendlyDateRange ? `Weeks: ${currentFilters?.friendlyDateRange}` : "",
            getSingleItemOrCount(currentFilters?.locations?.selectedLocations, "Location"),
            getSingleItemOrCount(currentFilters?.schedules?.selectedSchedules, "Schedule")
        ];

        return ` Filters: ${filtersTextSegements.filter(s => s).join(" | ")}`;
    });

    const appliedFilters = computed((): GroupSchedulerAppliedFiltersBag => {
        return {
            filters: filters.value,
            scheduleOccurrences: scheduleOccurrences.value
        };
    });

    const occurrencesByDate = computed((): Record<string, GroupSchedulerOccurrenceBag[]> => {
        if (!scheduleOccurrences.value?.length) {
            return {};
        }

        const occurrences: Record<string, GroupSchedulerOccurrenceBag[]> = {};
        scheduleOccurrences.value
            .filter((o: GroupSchedulerOccurrenceBag) => o.occurrenceDate)
            .forEach((o: GroupSchedulerOccurrenceBag) => {
                const date = o.occurrenceDate || "";
                let dateOccurrences = occurrences[date];

                if (!dateOccurrences) {
                    dateOccurrences = [];
                    occurrences[date] = dateOccurrences;
                }

                dateOccurrences.push(o);
            });

        return occurrences;
    });

    const occurrenceDateCount = computed((): number => {
        return Object.keys(occurrencesByDate.value).length;
    });

    const showPrevNextButtons = computed((): boolean => {
        if (!occurrenceDateCount.value) {
            return false;
        }

        // If we have more than once occurrence date, show the prev/next buttons.
        if (occurrenceDateCount.value > 1) {
            return true;
        }

        /*
         * If we got here, this means we have eactly one occurrence date; check to see if this date contains
         * more than one schedule. If so, show the prev/next buttons.
         */
        const uniqueScheduleIds: number[] = [];
        occurrencesByDate[Object.keys(occurrencesByDate.value)[0]]?.forEach((o: GroupSchedulerOccurrenceBag) => {
            if (!uniqueScheduleIds.some((id: number) => id === o.scheduleId)) {
                uniqueScheduleIds.push(o.scheduleId);
            }
        });

        return uniqueScheduleIds.length > 0;
    });

    // #endregion

    // #region Functions

    /**
     * Scrolls to the previous or next schedule element.
     *
     * @param currentDateIndex The index of the occurrenceDate component currently within view.
     * @param currentScheduleIndex The index of the schedule component (within a given occurrence date) currently within view.
     * @param direction The direction to scroll.
     */
    function scrollToSchedule(currentDateIndex: number, currentScheduleIndex: number, direction: ScrollDirection): void {
        let targetSchedules = scheduleElementsByOccurrenceDate.value[currentDateIndex];
        let targetScheduleIndex = direction == ScrollDirection.Previous ? currentScheduleIndex - 1 : currentScheduleIndex + 1;

        if (direction == ScrollDirection.Previous) {
            if (targetScheduleIndex < 0) {
                // The first schedule of a given occurrence date is currently within view.
                if (occurrenceDateCount.value > 1) {
                    // There is more than one occurrence date; go to the last schedule of the previous occurrence date.
                    targetSchedules = scheduleElementsByOccurrenceDate.value[currentDateIndex === 0 ? occurrenceDateCount.value - 1 : currentDateIndex - 1];
                }
                else {
                    // There is only one occurrence date; go to the last schedule within this same occurrence date.
                }

                if (targetSchedules?.length) {
                    scrollTo(targetSchedules[targetSchedules.length - 1]);
                }
            }
            else {
                // Go to the previous schedule within this same occurrence date.
                if (targetSchedules?.length ?? 0 > targetScheduleIndex) {
                    scrollTo(targetSchedules[targetScheduleIndex]);
                }
            }
        }
        else if (direction == ScrollDirection.Next) {
            if (!targetSchedules) {
                return;
            }

            if (targetScheduleIndex > targetSchedules.length - 1) {
                // The last schedule of a given occurrence is currently within view.
                if (occurrenceDateCount.value > 1) {
                    // There is more than one occurrence date; go to the first schedule of the next occurrence date.
                    targetSchedules = scheduleElementsByOccurrenceDate.value[currentDateIndex === occurrenceDateCount.value - 1 ? 0 : currentDateIndex + 1];
                }
                else {
                    // There is only one occurrece date; go to the first schedule within this same occurrence date.
                }

                if (targetSchedules?.length) {
                    scrollTo(targetSchedules[0]);
                }
            }
            else {
                // Go to the next schedule within this same occurrence date.
                if (targetSchedules?.length ?? 0 > targetScheduleIndex) {
                    scrollTo(targetSchedules[targetScheduleIndex]);
                }
            }
        }
    }

    /**
     * Scrolls to the specified element.
     *
     * @param element The element to scroll to.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function scrollTo(element: any): void {
        if (!element?.$el || !snapContainer.value) {
            return;
        }

        const elementLeft: number = element.$el.getBoundingClientRect()?.left ?? 0;
        const snapContainerScrollLeft: number = snapContainer.value?.scrollLeft ?? 0;

        snapContainer.value.scrollTo({
            left: elementLeft + snapContainerScrollLeft
        });
    }

    // #endregion

    // #region Event Handlers

    /**
     * Handles the click event of the "Filters..." elements, to show the `SelectFilters` component.
     */
    function onSelectFiltersClick(): void {
        isSelectingFilters.value = true;
    }

    /**
     * Handles the `filtersApplied` event of the `SelectFilters` component.
     *
     * @param appliedFilters The filters to apply.
     */
    function onFiltersApplied(appliedFilters: GroupSchedulerAppliedFiltersBag): void {
        filters.value = appliedFilters?.filters;
        scheduleOccurrences.value = appliedFilters.scheduleOccurrences;

        nextTick(() => {
            console.log("scrolling!");
            if (snapContainer.value) {
                snapContainer.value.scrollTo({
                    left: 0
                });
            }
        });
    }

    /**
     * Adds this occurrence date's schedule elements to the local collection so we can scroll between them.
     *
     * @param dateIndex The index of the occurrenceDate component from which this event originated.
     * @param scheduleElements The schedule elements that were created as children of the occurrenceDate component.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function onScheduleElementsCreated(dateIndex: number, scheduleElements: any[]): void {
        scheduleElementsByOccurrenceDate.value[dateIndex] = scheduleElements;
    }

    /**
     * Scrolls the previous schedule component into view.
     *
     * @param dateIndex The index of the occurrenceDate component from which this event originated.
     * @param currentIndex The index of schedule component currently within view.
     */
    function onGoPrevious(dateIndex: number, currentIndex: number): void {
        scrollToSchedule(dateIndex, currentIndex, ScrollDirection.Previous);
    }

    /**
     * Scrolls the next schedule component into view.
     *
     * @param dateIndex The index of the occurrenceDate component from which this event originated.
     * @param currentIndex The index of schedule component currently within view.
     */
    function onGoNext(dateIndex: number, currentIndex: number): void {
        scrollToSchedule(dateIndex, currentIndex, ScrollDirection.Next);
    }

    // #endregion

    provideSecurityGrant(securityGrant);

    onConfigurationValuesChanged(reloadBlock);
</script>
